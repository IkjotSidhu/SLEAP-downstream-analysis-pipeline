"""
SLEAP Analysis Pipeline

A comprehensive Python pipeline for analyzing animal tracking data generated by 
SLEAP (Social LEAP Estimates Animal Poses).

This module provides functions for:
- Loading and preprocessing SLEAP tracking data
- Analyzing trajectories and movement patterns
- Calculating inter-animal distances
- Computing velocity profiles
- Generating publication-quality visualizations

Author: Ikjot Sidhu
License: MIT
Version: 1.0.0
"""

import sys
import os
from pathlib import Path
from sleap import Labels
import seaborn as sns
import matplotlib as mpl
import matplotlib.pyplot as plt
import h5py
import numpy as np
from scipy.interpolate import interp1d
from scipy.signal import savgol_filter

# Configuration
class AnalysisConfig:
    """Configuration class for SLEAP analysis parameters."""
    def __init__(self):
        self.fps = 30
        self.velocity_window = 25
        self.velocity_poly_order = 3
        self.velocity_vmin = 0
        self.velocity_vmax = 20
        self.figure_format = 'pdf'
        self.figure_dpi = 300
        self.colormap = 'plasma'
        
    def update(self, **kwargs):
        """Update configuration parameters."""
        for key, value in kwargs.items():
            if hasattr(self, key):
                setattr(self, key, value)
            else:
                print(f"Warning: Unknown parameter '{key}' ignored")

def create_output_directory(output_dir):
    """Create output directory if it doesn't exist."""
    Path(output_dir).mkdir(parents=True, exist_ok=True)

def validate_file_path(file_path):
    """Validate that the input file exists and is readable."""
    if not os.path.exists(file_path):
        raise FileNotFoundError(f"File not found: {file_path}")
    
    if not file_path.endswith(('.h5', '.hdf5')):
        print(f"Warning: File '{file_path}' may not be a valid HDF5 file")

def get_data_summary(locations, node_names):
    """Generate a summary of the tracking data."""
    frame_count, node_count, _, instance_count = locations.shape
    
    # Calculate missing data percentage
    total_points = locations.size
    missing_points = np.isnan(locations).sum()
    missing_percentage = (missing_points / total_points) * 100
    
    summary = {
        'frame_count': frame_count,
        'node_count': node_count,
        'instance_count': instance_count,
        'node_names': node_names,
        'missing_data_percentage': missing_percentage,
        'total_tracking_points': total_points
    }
    
    return summary

def fill_missing(Y, kind="linear"):
    """
    Fills missing values independently along each dimension after the first.
    
    Parameters:
    -----------
    Y : np.ndarray
        Input array with missing values (NaN)
    kind : str
        Interpolation method ('linear', 'cubic', etc.)
        
    Returns:
    --------
    np.ndarray
        Array with missing values filled
    """
    # Store initial shape.
    initial_shape = Y.shape

    # Flatten after first dim.
    Y = Y.reshape((initial_shape[0], -1))

    # Interpolate along each slice.
    for i in range(Y.shape[-1]):
        y = Y[:, i]

        # Skip if all values are NaN
        if np.all(np.isnan(y)):
            continue
            
        # Build an interpolant.
        x = np.flatnonzero(~np.isnan(y))
        if len(x) < 2:  # Need at least 2 points for interpolation
            continue
            
        f = interp1d(x, y[x], kind=kind, fill_value=np.nan, bounds_error=False)

        # Fill missing
        xq = np.flatnonzero(np.isnan(y))
        y[xq] = f(xq)
        
        # Fill leading or trailing NaNs with the nearest non-NaN values
        mask = np.isnan(y)
        if np.any(~mask):  # Only interpolate if there are non-NaN values
            y[mask] = np.interp(np.flatnonzero(mask), np.flatnonzero(~mask), y[~mask])

        # Save slice
        Y[:, i] = y

    # Restore to initial shape.
    Y = Y.reshape(initial_shape)

    return Y

def instance_node_velocities(locations, instance_idx, frame_count, node_count):
    """Calculate velocities for all nodes of a specific instance."""
    fly_node_locations = locations[:, :, :, instance_idx]
    fly_node_velocities = np.zeros((frame_count, node_count))

    for n in range(0, node_count):
        fly_node_velocities[:, n] = smooth_diff(fly_node_locations[:, n, :])
    
    return fly_node_velocities
    
def plot_instance_node_velocities(instance_idx, node_velocities, node_names):
    """Plot velocity heatmap for all nodes of an instance."""
    plt.figure(figsize=(20, 8))
    plt.imshow(node_velocities.T, aspect='auto', vmin=0, vmax=20, interpolation="nearest", cmap='plasma')
    plt.xlabel('Frames')
    plt.ylabel('Nodes')
    plt.yticks(np.arange(len(node_names)), node_names, rotation=20)
    plt.title(f'Instance {instance_idx} node velocities')
    plt.colorbar(label='Velocity (pixels/frame)')
    plt.tight_layout()

def smooth_diff(node_loc, win=25, poly=3):
    """
    Calculate smoothed velocity from position data.
    
    Parameters:
    -----------
    node_loc : np.ndarray
        Position array of shape [frames, 2] (x, y coordinates)
    win : int
        Window size for Savitzky-Golay filter (must be odd)
    poly : int
        Polynomial order for Savitzky-Golay filter
        
    Returns:
    --------
    np.ndarray
        Velocity magnitude array of shape [frames]
    """
    if node_loc.shape[0] < win:
        print(f"Warning: Window size ({win}) larger than data length ({node_loc.shape[0]}). Using smaller window.")
        win = min(node_loc.shape[0] // 2 * 2 + 1, 5)  # Ensure odd number, minimum 5
    
    if win % 2 == 0:  # Ensure window size is odd
        win += 1
        
    node_loc_vel = np.zeros_like(node_loc)
    
    for c in range(node_loc.shape[-1]):
        # Handle NaN values
        if np.all(np.isnan(node_loc[:, c])):
            node_loc_vel[:, c] = np.nan
        else:
            try:
                node_loc_vel[:, c] = savgol_filter(node_loc[:, c], win, poly, deriv=1)
            except ValueError as e:
                print(f"Error in velocity calculation: {e}")
                # Fallback to simple differentiation
                node_loc_vel[1:, c] = np.diff(node_loc[:, c])
                node_loc_vel[0, c] = node_loc_vel[1, c]
    
    # Calculate velocity magnitude
    node_vel = np.linalg.norm(node_loc_vel, axis=1)
    
    return node_vel
    
def load_sleap_data(file_path):
    """Load and preprocess SLEAP tracking data from HDF5 file."""
    with h5py.File(file_path, "r") as f:
        tracks = f["tracks"][:]  # Shape: (frames, nodes, instances, 2)
        dset_names = list(f.keys())
        locations = f["tracks"][:].T
        node_names = [n.decode() for n in f["node_names"][:]]
    
    # Print data info
    print("===filename===")
    print(file_path)
    print()
    
    print("===HDF5 datasets===")
    print(dset_names)
    print()
    
    print("===locations data shape===")
    print(locations.shape)
    print()
    
    print("===nodes===")
    for i, name in enumerate(node_names):
        print(f"{i}: {name}")
    print()
    
    frame_count, node_count, _, instance_count = locations.shape
    print("frame count:", frame_count)
    print("node count:", node_count)
    print("instance count:", instance_count)
    
    # Fill missing values
    locations = fill_missing(locations)
    
    return locations, node_names, frame_count, node_count, instance_count

def plot_node_trajectories(locations, node_index, node_name, output_dir="./"):
    """Plot node location trajectories over time."""
    nod_loc = locations[:, node_index, :, :]
    
    # Time series plot
    plt.figure(figsize=(12, 6))
    plt.plot(nod_loc[:, 0, 0], 'y', label='mouse-1', linewidth=2)
    plt.plot(nod_loc[:, 0, 1], 'g', label='mouse-2', linewidth=2)
    plt.legend(loc="center right")
    plt.title(f"{node_name} X-coordinate over time")
    plt.xlabel("Frame")
    plt.ylabel("X position (pixels)")
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.savefig(f"{output_dir}/{node_name}_locations.pdf", format="pdf", bbox_inches="tight")
    plt.show()
    
    # Spatial trajectory plot
    plt.figure(figsize=(10, 10))
    plt.plot(nod_loc[:, 0, 0], nod_loc[:, 1, 0], 'y', label='mouse-1', alpha=0.7)
    plt.plot(nod_loc[:, 0, 1], nod_loc[:, 1, 1], 'g', label='mouse-2', alpha=0.7)
    plt.legend()
    plt.title(f"{node_name} Spatial Trajectories")
    plt.xlabel("X position (pixels)")
    plt.ylabel("Y position (pixels)")
    plt.axis('equal')
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.savefig(f"{output_dir}/{node_name}_Node-Mouse-Tracking-plot.pdf", format='pdf', bbox_inches="tight")
    plt.show()

def analyze_inter_mouse_distance(locations, node_index, node_name, fps=30, output_dir="./"):
    """Calculate and plot inter-mouse distances."""
    # Calculate inter-mouse distances
    mouse1_xy = np.stack([
        locations[:, node_index, 0, 0],  # x for mouse 1
        locations[:, node_index, 1, 0]   # y for mouse 1
    ], axis=1)

    mouse2_xy = np.stack([
        locations[:, node_index, 0, 1],  # x for mouse 2
        locations[:, node_index, 1, 1]   # y for mouse 2
    ], axis=1)

    # Compute Euclidean distance per frame
    inter_mouse_distance = np.linalg.norm(mouse1_xy - mouse2_xy, axis=1)

    # Plot distance by frame
    plt.figure(figsize=(12, 6))
    plt.plot(inter_mouse_distance, linewidth=2)
    plt.xlabel("Frame")
    plt.ylabel("Inter-Mouse Distance (pixels)")
    plt.title("Distance between mice over time")
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.savefig(f"{output_dir}/{node_name}_Inter-Mouse-Distance-by-Frame.pdf", format='pdf', bbox_inches="tight")
    plt.show()

    # Plot distance by time
    time = np.arange(len(inter_mouse_distance)) / fps
    plt.figure(figsize=(12, 6))
    plt.plot(time, inter_mouse_distance, label='Inter-mouse Distance', linewidth=2)
    plt.xlabel("Time (s)")
    plt.ylabel("Distance (pixels)")
    plt.title("Distance Between Mice Over Time")
    plt.grid(True, alpha=0.3)
    plt.legend()
    plt.tight_layout()
    plt.savefig(f"{output_dir}/{node_name}_Inter-Mouse-Distance-by-second.pdf", format='pdf', bbox_inches="tight")
    plt.show()
    
    return inter_mouse_distance

def analyze_velocities(locations, node_index, node_name, output_dir="./"):
    """Calculate and plot velocity profiles for both mice."""
    nod_loc = locations[:, node_index, :, :]
    
    # Calculate velocities for both mice
    vel_mouse1 = smooth_diff(nod_loc[:, :, 0])
    vel_mouse2 = smooth_diff(nod_loc[:, :, 1])
    
    # Plot for Mouse 1
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(15, 8), sharex=True)
    ax1.plot(nod_loc[:, 0, 0], 'k', label='x', linewidth=1.5)
    ax1.plot(-1 * nod_loc[:, 1, 0], 'r', label='-y', linewidth=1.5)
    ax1.legend()
    ax1.set_title(f'Mouse 1 - {node_name} Position')
    ax1.grid(True, alpha=0.3)
    
    im = ax2.imshow(vel_mouse1[:, np.newaxis].T, aspect='auto', vmin=0, vmax=10, cmap='plasma')
    ax2.set_yticks([])
    ax2.set_title('Velocity')
    ax2.set_xlabel('Frame')
    
    plt.colorbar(im, ax=ax2, label='Velocity (pixels/frame)')
    plt.tight_layout()
    plt.savefig(f"{output_dir}/Mouse-1-{node_name}-velocity-plot.pdf", format='pdf', bbox_inches="tight")
    plt.show()
    
    # Plot for Mouse 2
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(15, 8), sharex=True)
    ax1.plot(nod_loc[:, 0, 1], 'k', label='x', linewidth=1.5)
    ax1.plot(-1 * nod_loc[:, 1, 1], 'r', label='-y', linewidth=1.5)
    ax1.legend()
    ax1.set_title(f'Mouse 2 - {node_name} Position')
    ax1.grid(True, alpha=0.3)
    
    im = ax2.imshow(vel_mouse2[:, np.newaxis].T, aspect='auto', vmin=0, vmax=10, cmap='plasma')
    ax2.set_yticks([])
    ax2.set_title('Velocity')
    ax2.set_xlabel('Frame')
    
    plt.colorbar(im, ax=ax2, label='Velocity (pixels/frame)')
    plt.tight_layout()
    plt.savefig(f"{output_dir}/Mouse-2-{node_name}-velocity-plot.pdf", format='pdf', bbox_inches="tight")
    plt.show()
    
    return vel_mouse1, vel_mouse2

def analyze_cumulative_distance(locations, node_index, node_name, output_dir="./"):
    """Calculate and plot cumulative distance traveled."""
    plt.figure(figsize=(12, 6))
    
    for instance in [0, 1]:  # Loop over two mice
        x = locations[:, node_index, 0, instance]
        y = locations[:, node_index, 1, instance]
        xy = np.stack([x, y], axis=1)  # shape: (frames, 2)
    
        # Compute per-frame displacement
        diffs = np.diff(xy, axis=0)
        distances = np.linalg.norm(diffs, axis=1)
    
        # Compute cumulative distance
        cumulative_distance = np.cumsum(distances)
    
        # Plot
        plt.plot(cumulative_distance, label=f"Mouse {instance+1} ({node_name})", linewidth=2)
    
    # Final plot styling
    plt.xlabel("Frame")
    plt.ylabel("Cumulative Distance Traveled (pixels)")
    plt.title(f"Cumulative Distance Over Time — Node: {node_name}")
    plt.legend()
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.savefig(f'{output_dir}/Cumulative-distance-over-time-{node_name}.pdf', format='pdf', bbox_inches="tight")
    plt.show()

def plotting_SLEAP(file_path, main_node, fps=30, output_dir="./"):
    """Main analysis pipeline for SLEAP tracking data."""
    # Validate inputs
    validate_file_path(file_path)
    create_output_directory(output_dir)
    
    # Load data
    locations, node_names, frame_count, node_count, instance_count = load_sleap_data(file_path)
    
    # Validate node name
    if main_node not in node_names:
        raise ValueError(f"Node '{main_node}' not found in data. Available nodes: {node_names}")
    
    node_index = node_names.index(main_node)
    
    # Print data summary
    summary = get_data_summary(locations, node_names)
    print(f"Data Summary:")
    print(f"- Frames: {summary['frame_count']}")
    print(f"- Nodes: {summary['node_count']}")
    print(f"- Instances: {summary['instance_count']}")
    print(f"- Missing data: {summary['missing_data_percentage']:.2f}%")
    print()
    
    # Run all analyses
    plot_node_trajectories(locations, node_index, main_node, output_dir)
    inter_mouse_distance = analyze_inter_mouse_distance(locations, node_index, main_node, fps, output_dir)
    vel_mouse1, vel_mouse2 = analyze_velocities(locations, node_index, main_node, output_dir)
    analyze_cumulative_distance(locations, node_index, main_node, output_dir)
    
    return {
        'locations': locations,
        'node_names': node_names,
        'inter_mouse_distance': inter_mouse_distance,
        'velocities': {'mouse1': vel_mouse1, 'mouse2': vel_mouse2},
        'summary': summary
    }

def main():
    """Example usage of the SLEAP analysis pipeline."""
    # Example configuration
    config = AnalysisConfig()
    config.update(fps=30, velocity_window=15)  # Customize as needed
    
    # Example usage (replace with your actual file path and node name)
    file_path = "path/to/your/sleap_output.h5"
    main_node = "bodycenter"  # or whatever node you want to analyze
    output_dir = "./analysis_results"
    
    try:
        results = plotting_SLEAP(
            file_path=file_path,
            main_node=main_node,
            fps=config.fps,
            output_dir=output_dir
        )
        print("Analysis completed successfully!")
        print(f"Results saved to: {output_dir}")
        
    except Exception as e:
        print(f"Error during analysis: {e}")

if __name__ == "__main__":
    main()


